Libft 

TYPE
•c02ex02 isalpha
•	 isdigit
•c02ex03 isalnum
•******* isascii  vérifie si c est un unsigned char sur 7 bits, entrant dans  le  jeu  de  caractères
              ASCII.
•c02ex06 isprint


•c01ex06 strlen	int strlen(char *str); compte le nombre de caractères dans une chaîne de carac-
tères et qui retourne le nombre trouvé
•	 memset	void *memset (void *s, int c, size_t n);  remplit les n premiers octets de la zone mémoire pointée par s avec l'octet c.  renvoie un pointeur sur la zone mémoire s.  
•	 bzero		void bzero(void *s, size_t n); met à 0 (octets contenant « \0 ») les n premiers octets du bloc pointé par s. Ne renvoie rien


COPY
•	memcpy	void *memcpy(void *dest, const void *src, size_t n); copie n octets depuis la zone mémoire src vers la zone mémoire dest. Les deux zones ne doivent pas se chevaucher. Si c'est le cas, utilisez plutôt memmove(3). envoie un pointeur sur dest.
•memmove void *memmove(void *dest, const void *src, size_t n); copie n octets depuis la zone mémoire src vers la zone mémoire dest. Les deux zones peuvent se chevaucher : la copie se passe comme si les octets de src étaient d'abord copiés dans une zone temporaire qui ne chevauche ni src ni dest, et les octets sont ensuite copiés de la zone temporaire vers dest.  
•c02ex10 strlcpy La fonction strcpy() copie la chaîne pointée par src (y compris l'octet nul « \0 » final) dans la chaîne pointée par dest. Les deux chaînes ne doivent pas se chevaucher. La chaîne dest doit être assez grande pour accueillir la copie.
La fonction strncpy() est identique, sauf que seuls les n premiers octets de src sont copiés. Avertissement : s'il n'y a pas d'octet nul dans les n premiers octets de src, la chaîne résultante dans dest ne disposera pas d'octet nul final. 
elles renvoient un pointeur sur la chaîne destination dest.


•c03ex05 strlcat	char *strncat(char *dest, const char *src, size_t n); 
 ajoute la chaîne src à la fin de la chaîne dest en écrasant le caractère nul (« \0 ») à la fin de dest, puis en ajoutant un nouveau caractère nul final. Les chaînes ne doivent pas se chevaucher, et la chaîne dest doit être assez grande pour accueillir le résultat.
La fonction strncat() est identique, à la différence que
*   elle ne prend en compte que les n premiers caractères de src ; et 
*   src n'a pas besoin d'octet nul final si elle contient n caractères ou plus. 
Comme pour strcat(), la chaîne résultante dans dest est toujours terminée par un caractère nul. Si src contient n caractères ou plus, strncat() écrit n+1 caractères dans dest (n caractères de src plus l'octet nul final). Aussi, la taille de dest doit être au moins strlen(dest)+n+1. 

•c02ex07 toupper  convertit la lettre c en majuscule si c'est possible. 
•c02ex08 tolower

•	strchr char *strchr(const char *s, int c); Rechercher un caractère dans une chaîne. renvoie un pointeur sur la première occurrence du caractère c dans la chaîne s. 
•	strrchr char *strrchr(const char *s, int c); Rechercher un caractère dans une chaîne. renvoie un pointeur sur la dernière occurrence du caractère c dans la chaîne s
•c03ex01	strncmp int ft_strncmp(char *s1, char *s2, unsigned int n);
•	memchr void *memchr(const void *s, int c, size_t n); examine les n premiers octets de la zone mémoire pointée par s à la recherche du caractère c. Le premier octet correspondant à c (interprété comme un unsigned char) arrête l'opération. 
•	memcmp int memcmp(const void *s1, const void *s2, size_t n); compare les n premiers octets des zones mémoire s1 et s2. Elle renvoie un entier inférieur, égal, ou supérieur à zéro, si s1 est respectivement inférieure, égale ou supérieur à s2. 
•c03ex04	strnstr char *strnstr(const char *s1, const char *s2, size_t len ); Find the first substring in a length-limited string 
•c04ex03	atoi int atoi(const char *str); convertit le début de la chaîne pointée par str en entier de type int. Le résultat est identique à un appel 


PROTO

int ft_isalpha(int c);
int ft_isdigit(int c);
int ft_isalnum(int c);
int ft_isascii(int c);
int ft_isprint(int c);
int ft_strlen(char *s);
void *ft_memset (void *s, int c, size_t n); 
void ft_bzero(void *s, size_t n);
void *ft_memcpy(void *dest, const void *src, size_t n);
void *ft_memmove(void *dest, const void *src, size_t n);
unsigned int ft_strlcpy(char *dest, char *src, unsigned int size);
unsigned int ft_strlcat(char *dest, char *src, unsigned int size);
int ft_toupper(int c);
int ft_tolower(int c);
char *ft_strchr(const char *s, int c);
char *ft_strrchr(const char *s, int c);
int ft_strncmp(char *s1, char *s2, unsigned int n);
void *ft_memchr(const void *s, int c, size_t n);
int ft_memcmp(const void *s1, const void *s2, size_t n);
char *ft_strnstr(const char *s1, const char *s2, size_t len);
int ft_atoi(const char *str);
